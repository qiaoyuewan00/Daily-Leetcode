# 深度优先搜索 `DFS`

* 尽可能往深了搜 到头了就回溯；不具有最短路这个性质
* `stack`
* **O（h）** 对空间要求比较高
* 回溯 和 剪枝
* 回溯一定要注意恢复现场

# 宽度优先搜索 `BFS`

* 按层往下扩展，一层一层往下扩展；存在**最短路**这个性质（**如果每条边的权重都是1的时候**，第一次扩展到的都是距离最小的点）
* 用 `queue`
* O（2^h)

# 树与图的存储

* 树是无环连通图，是特殊的图

## 有向图

* 邻接矩阵 `g[a,b]` 浪费空间，适合存储稠密图

* 邻接表（用得多）

  每一个节点都是单链表，开`n`个单链表

  单链表内部点的次序不重要

  

# 树与图的深度优先遍历

# 树与图的宽度优先遍历

# 拓扑排序

有向图才有拓扑序列

拓扑序列：有向图的每条边都从前指到后（比如1永远在2前面，2永远在3前面）

不是所有图都有拓扑序列；环没有拓扑序列；有向无环图一定存在拓扑序列

有向无环图一定至少存在一个入度为0的点

入度为0的点可以排在当前最前面的位置

```
queue<----所有入度为0的点
while queue不空
{
	t<---队头
	枚举t的所有出边 t->j
	删掉t->j  d[j]--；    // d[j]表示入度
	if d[j]==0:
		queue<---j
}
```

