# 思路

**理解：**

针对二维的背包问题进行优化，回顾一下二维的01背包问题，`dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+val[i])`，其中`dp[i][j]`指的是前`i`个物品在容量为`j`的背包里最大利益

那么`i`表示的都是物品，如果进行直接消去，得到`dp[j] = max(dp[j],dp[j-weight[i]]+val[i]`，可以这么理解：背包容量为`j`等于装/不装当前物品，换到实际的二维数组就可以理解为`dp[j]`为容量为`j`的背包的最大价值

滚动数组：用前面一排数据来操作得到后面一排数据，每次只需要更新一次数据就可以，这里的滚动数组就是二维里的每一列，因为更新的是每个背包容量`j`

**初始化：**

只要对`dp[0]=0`初始化就可以，别的都会由`dp[0]`得到（最大的非负`dp`值）

**遍历顺序1：**

应该从后往前放入物品，为什么？背包容量是从大到小，这样保证了一个物品只被放入一次，比如容量从4-3-2-1，那如果容量为4已经放了物品`weight[i]=1`，那么后面就不会放物品`i`了；如果是背包容量从小到大，那么会导致放了物品`i`以后有空余容量再放物品`i`，违背01背包原则。**保证只放一个物品**

**遍历顺序2：**

在二维里的遍历顺序是随意的，两重循环可以交换，但是这里不行，这里必须先物品再容量，因为如果先容量再物品，会导致每个容量只有一个物品。**背包不能只有一个物品**

![image-20250117013010013](C:/Users/HUAWEI/AppData/Roaming/Typora/typora-user-images/image-20250117013010013.png)

**输出：**

`dp[j]`表示容量为`j`的背包的最大价值，那么答案就是`dp[bagweight]`

```python
for i in range(N):
    for j in range(bagweight,weight[i]-1,-1):
        dp[j] = max(dp[j],dp[j-weight[i]]+val[i])
```



**注意：**Python的从大到小循环遍历是`[a,b)`的形式，记得要`(a,b-1,-1)`这样的参数设置

# 题目

- [ ] https://kamacoder.com/problempage.php?pid=1046